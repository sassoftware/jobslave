#
# Copyright (c) 2004-2006 rPath, Inc.
#
# All Rights Reserved
#

# python standard library imports
import errno
from math import ceil
import os
import sys
import re
import pwd
import stat
import time
import tempfile
import zipfile

# mint imports
from jobslave import buildtypes, jobslave_error
from jobslave.generators import gencslist, constants
from jobslave.generators.imagegen import ImageGenerator, MSG_INTERVAL
#from mint.client import upstream

# conary imports
from conary import conaryclient
from conary import flavorcfg
from conary import versions
from conary.conarycfg import ConfigFile, CfgDict, CfgString, CfgBool
from conary.callbacks import UpdateCallback
from conary.conaryclient.cmdline import parseTroveSpec
from conary.deps import deps
from conary.lib import log, util
from conary.repository import errors

def getTroveSize(troveSpec):
    from conary import versions
    from conary.deps import deps
    from conary import conaryclient
    cc = conaryclient.ConaryClient()
    repos = cc.getRepos()
    n, v, f = conaryclient.cmdline.parseTroveSpec(troveSpec)
    NVF = repos.findTrove(None, (n, v, f), cc.cfg.flavor)[0]
    trove = repos.getTrove(*NVF)
    return trove.troveInfo.size()

def roundUpSize(size):
    # 13% accounts for reserved block and inode consumption
    size = int(math.ceil((size + TAGSCRIPT_GROWTH + SWAP_SIZE) / 0.87))
    # now round up to next cylinder size
    return size + ((CYLINDERSIZE - (size % CYLINDERSIZE)) % CYLINDERSIZE)

def getGrubConf(name, hasInitrd = True, xen = False, dom0 = False):
    xen = xen or dom0
    macros = {'name': name,
              'kversion'  : 'template',
              'initrdCmd' : '',
              'moduleCmd' : '',
              'timeOut'   : '5',
              'bootDev'   : 'hda',
              'kernelCmd' : 'kernel /boot/vmlinuz-%(kversion)s ro root=LABEL=/'}
    if hasInitrd:
        if dom0:
            macros['initrdCmd'] = 'module /boot/initrd-%(kversion)s.img'
        else:
            macros['initrdCmd'] = 'initrd /boot/initrd-%(kversion)s.img'
    macros['moduleCmd'] = ''
    if xen and not dom0:
        macros['bootDev'] = 'xvda'
        macros['timeOut'] = '0'
        macros['kernelCmd'] += ' quiet'
    elif xen and dom0:
        macros['moduleCmd'] = 'module /boot/vmlinuz-%(kversion)s ro ' \
            'root=LABEL=/'
        macros['kernelCmd'] = 'kernel /boot/xen.gz-%(kversion)s'
    r = '\n'.join(('#grub.conf generated by rBuilder',
                   '#',
                   '# Note that you do not have to rerun grub after ' \
                       'making changes to this file',
                   '#boot=%(bootDev)s',
                   'default=0',
                   'timeout=%(timeOut)s',
                   'title %(name)s (%(kversion)s)',
                   '    root (hd0,0)',
                   '    %(kernelCmd)s',
                   '    %(initrdCmd)s',
                   '    %(moduleCmd)s'
                   ))
    while '%' in r:
        r = r % macros
    r = '\n'.join([x for x in r.split('\n') if x.strip()])
    r += '\n\n'
    return r

# this function is no longer used.
def getManifest(xorg = True, gpm = True):
    manifest = {
        'fstab' : os.path.join('etc', 'fstab'),
        'hosts' : os.path.join('etc', 'hosts'),
        'ifcfg-eth0' : os.path.join('etc', 'sysconfig', 'network-scripts',
                                    'ifcfg-eth0'),
        'init.sh' : os.path.join('tmp', 'init.sh'),
        'keyboard' : os.path.join('etc', 'sysconfig', 'keyboard'),
        'network' : os.path.join('etc', 'sysconfig', 'network')
        }
    xorgFiles = {
        'xorg.conf' : os.path.join('etc', 'X11', 'xorg.conf')
        }
    gpmFiles = {
        'mouse' : os.path.join('etc', 'sysconfig', 'mouse'),
        }
    if xorg:
        manifest.update(xorgFiles)
    if gpm:
        manifest.update(gpmFiles)
    return manifest

def timeMe(func):
    def wrapper(self, *args, **kwargs):
        clock = time.clock()
        actual = time.time()
        returner = func(self, *args, **kwargs)
        log.info("%s: %.5f %.5f" % (func.__name__, time.clock() - clock, time.time() - actual))
        return returner
    return wrapper

def outputfilesize(func):
    def wrapper(self, *args, **kwargs):
        returner = func(self, *args, **kwargs)
        st = os.stat(self.outfile)
        log.debug("size of %s after %s: %d bytes" % (self.outfile, func.__name__, st.st_size))
        return returner
    return wrapper

def copyfile(source, target):
    if not os.path.exists(target):
        return util.copyfile(source, target)

def copytree(source, dest, exceptions = []):
    for root, dirs, files in os.walk(source):
        root = root.replace(source, '')
        for f in files:
            if not [x for x in exceptions if \
                        re.match(x, util.joinPaths(root, f))]:
                copyfile(util.joinPaths(source, root, f),
                         util.joinPaths(dest, root, f))
        for d in dirs:
            dir = util.joinPaths(dest, root, d)
            if not os.path.exists(dir) and not \
                    [x for x in exceptions if \
                         re.match(x, util.joinPaths(root, d))]:
                os.mkdir(dir)
                dStat = os.stat(util.joinPaths(source, root, d))
                os.chmod(dir, dStat[stat.ST_MODE])

class InstallCallback(UpdateCallback):
    def restoreFiles(self, size, totalSize):
        if totalSize != 0:
            self.restored += size
            self.update('Writing files')

    def requestingChangeSet(self):
        self.update('Requesting changeset')

    def downloadingChangeSet(self, got, need):
        if need != 0:
            self.update('Downloading changeset')

    def requestingFileContents(self):
        self.update('Requesting file contents')

    def downloadingFileContents(self, got, need):
        if need != 0:
            self.update('Downloading files')

    def preparingChangeSet(self):
        self.update('Preparing changeset')

    def resolvingDependencies(self):
        self.update('Resolving dependencies')

    def creatingRollback(self):
        self.update('Creating rollback')

    def creatingDatabaseTransaction(self, troveNum, troveCount):
        self.update('Creating database transaction')

    def committingTransaction(self):
        self.update('Committing transaction')

    def setUpdateHunk(self, num, total):
        self.updateHunk = (num, total)
        self.restored = 0

    def update(self, msg):
        curTime = time.time()
        # only push an update into the database if it differs from the
        # current message
        if self.updateHunk[1] != 0:
            percent = (self.updateHunk[0] * 100) / self.updateHunk[1]
            msg = "Updating changesets: %d%% (%s)" % (percent, msg)

        if self.msg != msg and (curTime - self.timeStamp) > MSG_INTERVAL:
            self.msg = msg
            self.status(msg)
            self.timeStamp = curTime

    def __init__(self, status):
        self.exceptions = []
        self.abortEvent = None
        self.status = status
        self.restored = 0
        self.updateHunk = (0, 0)
        self.msg = ''
        self.changeset = ''
        self.prefix = 'BDI:'
        self.timeStamp = 0

        UpdateCallback.__init__(self)


class BootableImage(ImageGenerator):
    @outputfilesize
    @timeMe
    def prepareDiskImage(self):
        #create the disk file this will blank the file if it exists.
        ofile = open(self.outfile, 'wb', 0644)
        ofile.seek(self.imagesize-1)
        ofile.write('\x00')
        ofile.close()

        #Do the partition table
        self.cylinders = self.imagesize / self.imgcfg.cylindersize
        cmd = '/sbin/sfdisk -C %d -S %d -H %d %s' % (self.cylinders, self.imgcfg.sectors, self.imgcfg.heads, self.outfile)
        input = "0 %d L *\n" % self.cylinders

        if not self.imgcfg.debug:
            cmd += " >& /dev/null"
        sfdisk = util.popen(cmd, 'w')
        sfdisk.write(input)
        retval = sfdisk.close()

    def _writefstab(self):
        util.copyfile(os.path.join(self.imgcfg.dataDir, 'fstab'), os.path.join(self.fakeroot, 'etc', 'fstab'))
        if not self.swapSize:
            # remove any reference to swap if swapSize is 0
            util.execute('sed -i "s/.*swap.*//" %s' % \
                         os.path.join(self.fakeroot, 'etc', 'fstab'))

    def setupGrub(self, fakeRoot):
        if not os.path.exists(os.path.join(fakeRoot, 'sbin', 'grub')):
            log.info("grub not found. skipping setup.")
            return
        util.copytree(os.path.join(fakeRoot, 'usr', 'share', 'grub', '*', '*'), os.path.join(fakeRoot, 'boot', 'grub'))

        #Create a stub grub.conf
        if os.path.exists(os.path.join(fakeRoot, 'etc', 'issue')):
            f = open(os.path.join(fakeRoot, 'etc', 'issue'))
            name = f.readline().strip()
            f.close()
        else:
            name = self.jobData['project']['name']
        bootDirFiles = os.listdir(os.path.join(fakeRoot, 'boot'))
        xen = bool([x for x in bootDirFiles if re.match('vmlinuz-.*xen.*', x)])
        dom0 = bool([x for x in bootDirFiles if re.match('xen.gz-.*', x)])
        hasInitrd = bool([x for x in bootDirFiles \
                              if re.match('initrd-.*.img', x)])
        conf = getGrubConf(hasInitrd, xen, dom0)

        f = open(os.path.join(fakeRoot, 'boot', 'grub', 'grub.conf'), 'w')
        f.write(conf)
        f.close()

        os.chmod(os.path.join(fakeRoot, 'boot/grub/grub.conf'), 0600)
        #create the appropriate links
        os.symlink('grub.conf', os.path.join(fakeRoot, 'boot', 'grub', 'menu.lst'))
        os.symlink('../boot/grub/grub.conf', os.path.join(fakeRoot, 'etc', 'grub.conf'))

    def findFile(self, baseDir, fileName):
        for base, dirs, files in os.walk(baseDir):
            matches = [x for x in files if re.match(fileName, x)]
            if matches:
                print >> sys.stderr, "match found for %s" % \
                      os.path.join(base, matches[0])
                return os.path.join(base, matches[0])
        return None

    @timeMe
    def createTemporaryRoot(self, fakeRoot):
        for d in ('etc', 'etc/sysconfig', 'etc/sysconfig/network-scripts',
                  'boot/grub', 'tmp', 'proc', 'sys', 'root', 'var'):
            util.mkdirChain(os.path.join(fakeRoot, d))

    @timeMe
    def setupConaryClient(self, fakeRoot):
        self.conarycfg.threaded = True

        self.conarycfg.root = fakeRoot
        self.conarycfg.dbPath = '/var/lib/conarydb'
        self.conarycfg.installLabelPath = None
        self.readConaryRc(self.conarycfg)
        self.conarycfg.configLine('pinTroves kernel.*')

        self.cc = conaryclient.ConaryClient(self.conarycfg)

    @timeMe
    def updateGroupChangeSet(self, callback):
        itemList = [(self.baseTrove, (None, None), (self.baseversion, self.baseFlavor), True)]
        log.info("itemList: %s" % str(itemList))

        repos = self.cc.getRepos()
        parentGroup = repos.getTroves([(self.baseTrove, versions.VersionFromString(self.baseversion), self.baseFlavor)])[0]

        uJob, _ = self.cc.updateChangeSet(itemList,
            resolveDeps = False, split = True, callback = callback)
        return uJob

    @timeMe
    def applyUpdate(self, uJob, callback, tagScript, fakeRoot):
        self.cc.applyUpdate(uJob, tagScript=os.path.join(fakeRoot,
                                                         'root', tagScript),
                            autoPinList=self.conarycfg.pinTroves)

    @timeMe
    def updateKernelChangeSet(self, callback):
        #Install the Kernel
        try:
            # since sync = True, this will sync up to the kernel requested by the group.
            if self.baseFlavor.stronglySatisfies(deps.parseFlavor('use: xen')):
                kernel, version, flavor = parseTroveSpec('kernel:runtime')
            else:
                kernel, version, flavor = parseTroveSpec('kernel:runtime[!kernel.smp is: %s]' % self.arch)

            itemList = [(kernel, (None, None), (version, flavor), True)]
            uJob, suggMap = self.cc.updateChangeSet( \
                itemList, sync = True, split = True,
                resolveDeps = False)
        except errors.TroveNotFound:
            raise jobslave_error.KernelTroveRequired
        return uJob

    @timeMe
    def installKernel(self, fakeRoot, callback = None):
        if self.findFile(os.path.join(fakeRoot, 'boot'), 'vmlinuz.*'):
            log.info("kernel detected. skipping updateKernelChangeSet")
            return
        try:
            kuJob = self.updateKernelChangeSet(callback)
        except conaryclient.NoNewTrovesError:
            log.info("strongly-included kernel found--no new kernel trove to sync")
        except jobslave_error.KernelTroveRequired:
            log.info("no kernel found at all. skipping.")
        else:
            self.applyUpdate(kuJob, callback, 'conary-kernel-tag-script',
                             fakeRoot)

    @timeMe
    def fileSystemOddsNEnds(self, fakeRoot, swapSize):
        xorg = os.path.isfile(os.path.join(fakeRoot, 'usr', 'bin', 'X11', 'X'))
        gpm = os.path.isfile(os.path.join(fakeRoot, 'usr', 'sbin', 'gpm'))

        exceptFiles = []
        if not xorg:
            exceptFiles.append(os.path.join(os.path.sep, 'etc', 'X11.*'))
        if not gpm:
            exceptFiles.append(os.path.join(os.path.sep,
                                            'etc', 'sysconfig', 'mouse'))
        copytree(constants.skelDir, fakeRoot, exceptFiles)

        self.writeConaryRc(os.path.join(fakeRoot, 'etc', 'conary', 'config.d',
                                        self.basefilename), self.cc)

        # fix the fstab if needed
        if not swapSize:
            util.execute('sed -i "s/.*swap.*//" %s' % \
                             os.path.join(fakeRoot, 'etc', 'fstab'))
        else:
            #swap = open(os.path.join(fakeRoot, 'var', 'swap'), 'w')
            cmd = 'dd if=/dev/zero of=%s count=%d bs=%d; /sbin/mkswap %s' % \
                (os.path.join(fakeRoot, 'var', 'swap'), swapSize / 512, 512,
                 os.path.join(fakeRoot, 'var', 'swap'))
            util.execute(cmd)

        if xorg:
            #tweak the inittab to start at level 5
            cmd = r"/bin/sed -e 's/^\(id\):[0-6]:\(initdefault:\)$/\1:5:\2/' -i %s" % os.path.join(fakeRoot, 'etc', 'inittab')
            util.execute(cmd)

    @timeMe
    def createFileSystem(self, basedir = os.getcwd()):
        #This file isn't needed outside this function, and is cleaned up when it exits
        fd, file = tempfile.mkstemp('', 'mint-MDI-cFS-', basedir)
        os.close(fd)
        del fd
        try:
            #How much space do we need?
            fd = os.popen('/usr/bin/du -B1 --max-depth=0 %s' % self.fakeroot, 'r')
            size = int(fd.read().strip().split()[0])
            size += self.freespace + constants.partitionOffset
            # account for inodes and extra space for tag scripts and swap space
            # inodes are 8%.
            # super user reserved blocks are 5% of total
            # swap defaults to 128MB
            # tag scripts swag is 20MB
            size = int(ceil((size + 20 * 1024 * 1024 + self.swapSize) / 0.87))
            padding = self.imgcfg.cylindersize - (size % self.imgcfg.cylindersize)
            if self.imgcfg.cylindersize == padding:
                padding = 0
            self.imagesize = size + padding
            self.MakeE3FsImage(file)
            self.prepareDiskImage()
            self.WriteBack(file)
        finally:
            os.unlink(file)

    @timeMe
    def createSparseFile(self, size=10240):
        # size is defined in terms of megabytes
        fd, tmpFile = tempfile.mkstemp()
        os.close(fd)
        os.system('dd if=/dev/zero of=%s count=1 seek=%d bs=1M >/dev/null' % \
                  (tmpFile, size))
        return tmpFile

    @timeMe
    def estimateSize(self, fileName):
        "find real size of contents of sparse file by ignoring trailing nulls."
        # this function will fail if the file truly has trailing nulls.
        f = os.popen('du --block-size=1 %s' % fileName)
        upperSize = int(f.read().strip().split()[0])
        f.close()
        f = open(fileName)
        # iteratively back up in 1MB chunks until it appears to be within file
        lowerSize = max(upperSize - 1024 * 1024, 0)
        while lowerSize:
            f.seek(lowerSize)
            c = f.read(1)
            if c == chr(0) or c == '':
                lowerSize = max(lowerSize - 1024 * 1024, 0)
            else:
                break
        try:
            while True:
                estimatedSize = lowerSize + (upperSize - lowerSize) / 2
                sizeDiff = upperSize - estimatedSize
                f.seek(estimatedSize)
                buf = f.read(sizeDiff)
                if buf == len(buf) * chr(0):
                    # we are past the end of the file
                    upperSize = estimatedSize
                else:
                    if sizeDiff == 1:
                        estimatedSize = upperSize
                        break
                    # we're not pointing at the end of the file
                    lowerSize = estimatedSize
        finally:
            f.close()
        # size is in bytes
        return estimatedSize

    @timeMe
    def copySparse(self, src, dest):
        # overcome the apparent size of a sparse file. this would fail if there
        # were holes in the src file, but there shouldn't be any.
        f = os.popen('file %s' % src)
        fileType = f.read()
        f.close()
        if 'gzip compressed data' in fileType:
            # per RFC 1952: GZIP file format specification version 4.3
            # the last 8 bytes of gzip file are 32 bit CRC and 32 bit orig len.
            # for estimateSize to fail horribly, the uncompressed tarball would
            # need to be an exact multiple of 4GB and an all-zero CRC.
            # however gzip will complain if we truncate inadverdently.
            # HACK: we add 8 bytes to the esitmated size to virtually nullify
            # the chance of losing real data. gzip ignores trailing zeroes
            # this has a side effect of making gzip -l report orig size as 0
            size = self.estimateSize(src) + 8
            util.execute('head -c %d %s > %s' % (size, src, dest))
            return size
        else:
            fd = os.popen('/usr/bin/isosize %s' % src)
            size = int(fd.read().strip().split()[0])
            fd.close()
            size = size // 2048 + bool(size % 2048)
            # use dd to limit size. no python libs seem to do this correctly
            os.system('dd if=%s of=%s count=%d ibs=2048' % (src, dest, size))
            return size * 2048

    @timeMe
    def makeBootBlock(self):
        if not self.makeBootable:
            return
        if not os.path.exists(os.path.join(self.fakeroot, 'sbin', 'grub')):
            log.info("grub not found. skipping execution.")
            return
        #install boot manager
        cmd = '%s --device-map=/dev/null --batch' % os.path.join(self.fakeroot, 'sbin', 'grub')
        input = """
device  (hd0)   %s
root    (hd0,0)
setup   (hd0)
quit
""" % self.outfile

        if not self.imgcfg.debug:
            cmd += " > /dev/null"
        uml = util.popen(cmd, 'w')
        uml.write(input)
        retval = uml.close()

    @timeMe
    def stripBootBlock(self):
        tempName = self.outfile + "nonstrip"
        # move outfile out of the way, then copy it back, minus boot block.
        os.rename(self.outfile, tempName)
        blocks = constants.partitionOffset / 512
        os.system('dd if=%s of=%s skip=%d ibs=512' % \
                  (tempName, self.outfile, blocks))
        os.unlink(tempName)

    @timeMe
    def compressImage(self, filename):
        outfile = filename + '.gz'
        cmd = '/bin/gzip -c %s > %s' % (filename, outfile)
        util.execute(cmd)
        return outfile

    @timeMe
    def moveToFinal(self, filelist, finaldir):
        returnlist = []
        util.mkdirChain(finaldir)
        pardir = os.path.sep.join(finaldir.split(os.path.sep)[:-1])
        isogenUid = os.geteuid()
        apacheGid = pwd.getpwnam('apache')[3]
        # add the group writeable bit and assign group ownership to apache
        os.chown(finaldir, isogenUid, apacheGid)
        os.chmod(finaldir, os.stat(finaldir)[0] & 0777 | 0020)
        os.chown(pardir, isogenUid, apacheGid)
        os.chmod(pardir, os.stat(pardir)[0] & 0777 | 0020)
        for file, name in filelist:
            base, ext = os.path.basename(file).split(os.path.extsep, 1)
            newfile = os.path.join(finaldir, self.basefilename + "." + ext)
            log.info("Move %s to %s" % (file, newfile))

            import gencslist
            gencslist._linkOrCopyFile(file, newfile)
            os.unlink(file)
            os.chown(newfile, isogenUid, apacheGid)
            os.chmod(newfile, os.stat(newfile)[0] & 0777 | 0020)
            returnlist.append((newfile, name,))
        return returnlist

    def createFileTree(self):
        #Create the output file:
        fd, self.outfile = tempfile.mkstemp('.img', 'raw_hd')
        os.close(fd)
        os.chmod(self.outfile, 0644)

        callback = InstallCallback(self.status)

        self.setupConaryClient()
        self.status('Creating temporary root')
        self.createTemporaryRoot()

        self.status('Installing software')
        self.populateTemporaryRoot(callback)

        self.status('Populating configuration files')
        self.fileSystemOddsNEnds()

    def createImage(self, target = 'ext3'):
        self.status('Creating root file system')
        self.createFileSystem(self.cfg.imagesPath)

        self.status('Running tag-scripts')
        self.runTagScripts(target = target)

        if self.makeBootable:
            self.status('Installing bootloader')
            self.makeBootBlock()
        else:
            # don't try and strip boot blocks from iso images.
            if target in ('ext3', 'ext2'):
                self.stripBootBlock()

        #As soon as that's done, we can delete the fakeroot to free up space
        util.rmtree(self.fakeroot)
        self.fakeroot = None

    def __init__(self, jobData, response):
        ImageGenerator.__init__(self, jobData, response)

        #log.info('generating image with tmpdir %s', self.fakeroot)
        log.info('building trove: (%s, %s, %s)' % \
                 (self.baseTrove, self.baseVersion, str(self.baseFlavor)))

    def getTroveSize(self):
        NVF = self.nc.findTrove(None,
                                (self.baseTrove,
                                 self.baseVersion,
                                 self.baseFlavor),
                                self.conarycfg.flavor)[0]

        trv = self.nc.getTrove(NVF[0], NVF[1], NVF[2], withFiles = False)

        return trv.getSize()

    def getImageSize(self):
        # override this function as appropriate
        return self.getTroveSize()

    def makeBlankDisk(self, image, size):
        if os.path.exists(image):
            util.rmtree(image)
        util.execute('dd if=/dev/zero of=%s count=1 seek=%d bs=512' % \
                      (image, (size / 512) - 1))

        cylinders = size / constants.cylindersize
        cmd = '/sbin/sfdisk -C %d -S %d -H %d %s' % \
            (cylinders, constants.sectors, constants.heads, image)

        input = "0 %d L *\n" % cylinders

        sfdisk = util.popen(cmd, 'w')
        sfdisk.write(input)
        sfdisk.close()

        try:
            dev = self.loop(image, offset = 512)
            util.execute('mke2fs -L / -F %s' % dev)
            os.system('tune2fs -i 0 -c 0 -j %s' % dev)
        finally:
            if 'dev' in locals():
                util.execute('losetup -d %s' % dev)

    def makeBlankFS(self, image, size):
        if os.path.exists(image):
            util.rmtree(image)
        util.execute('dd if=/dev/zero of=%s count=1 seek=%d bs=512' % \
                      (image, (size / 512) - 1))

        util.execute('mke2fs -L / -F %s' % image)
        util.execute('tune2fs -i 0 -c 0 -j %s' % image)

    def loop(self, image, offset = 0):
        p = os.popen('losetup -f')
        dev = p.read().strip()
        p.close()
        util.execute('losetup %s %s %s' % \
                         (offset and ('-o%d' % offset) or '', dev, image))
        util.execute('sync')
        return dev

    def getKernelFlavor(self):
        flavor = ''
        if not self.baseFlavor.stronglySatisfies(deps.parseFlavor('use: xen')):
            flavor = '!kernel.smp is: %s' % self.arch
        return flavor

    def addScsiModules(self, dest):
        filePath = os.path.join(dest, 'etc', 'modprobe.conf')
        f = open(filePath, 'a')
        if os.stat(filePath)[6]:
            f.write('\n')
        f.write('\n'.join(('alias scsi_hostadapter mptbase',
                           'alias scsi_hostadapter1 mptspi')))
        f.close()

    def installFileTree(self, dest):
        #self.setupConaryClient(dest)
        self.createTemporaryRoot(dest)
        self.fileSystemOddsNEnds(dest, self.swapSize)
        fd, cfgPath = tempfile.mkstemp()
        try:
            os.close(fd)
            self.saveConaryRC(cfgPath)
            util.execute('mount -t proc none %s/proc' % dest)
            util.execute('mount -t sysfs none %s/sys' % dest)
            util.execute( \
                ("conary update '%s=%s[%s]' --root %s --config-file %s "
                 "--replace-files") % \
                    (self.baseTrove, self.baseVersion,
                     str(self.baseFlavor), dest, cfgPath))

            #copy the files needed by grub and set up the links
            self.setupGrub(dest)
            self.addScsiModules(dest)
            if not self.findFile(os.path.join(dest, 'boot'), 'vmlinuz.*'):
                util.execute(("conary sync 'kernel:runtime[%s]' --root %s "
                              "--config-file %s") % \
                                 (self.getKernelFlavor(), dest, cfgPath))
            else:
                log.info('Kernel detected, skipping.')
        finally:
            util.execute('umount %s/proc' % dest)
            util.execute('umount %s/sys' % dest)
            os.unlink(cfgPath)


        # remove root password
        os.system("chroot %s /usr/bin/authconfig --kickstart --enablemd5 --enableshadow --disablecache" % dest)
        os.system("chroot %s /usr/sbin/usermod -p '' root" % dest)

        # remove template kernel entry
        os.system('grubby --remove-kernel=/boot/vmlinuz-template --config-file=%s' % os.path.join(dest, 'boot', 'grub', 'grub.conf'))

    def installGrub(self, fakeRoot, image):
        grubPath = os.path.join(fakeRoot, 'sbin', 'grub')
        if not os.path.exists(grubPath):
            log.info("grub not found. skipping execution.")
            return

        p = os.popen('%s --device-map=/dev/null --batch' % grubPath, 'w')
        p.write('device (hd0) %s\n' % image)
        p.write('root (hd0,0)\n')
        p.write('setup (hd0)\n')
        return p.close()

    def gzip(self, imageFile):
        outFile = imageFile + '.gz'
        util.execute('gzip -c %s > %s' % (imageFile, outFile))
        return outFile

    @timeMe
    def zip(self, baseDir, outfile, extraArgs = ''):
        cwd = os.getcwd()
        try:
            dirPath, dirName = os.path.split(baseDir)
            os.chdir(dirPath)
            files = os.listdir(baseDir)
            for f in files:
                if f.endswith('.vmx'):
                    os.chmod(os.path.join(baseDir, f), 0755)
                else:
                    os.chmod(os.path.join(baseDir, f), 0600)
            util.execute('zip -rD%s %s %s' % (extraArgs, outfile, dirName))
        finally:
            try:
                os.chdir(cwd)
            except OSError, e:
                if e.errno == 2:
                    pass

    def write(self):
        raise NotImplementedError

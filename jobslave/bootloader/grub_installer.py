#
# Copyright (c) 2008-2009 rPath, Inc.
#
# All rights reserved
#

import os
import re
import stat

from conary.lib import log
from conary.lib import util

from jobslave import bootloader
from jobslave import buildtypes
from jobslave.distro_detect import *
from jobslave.generators import constants
from jobslave.imagegen import logCall

def getGrubConf(name, hasInitrd = True, xen = False, dom0 = False, clock = "",
                includeTemplate=True):
    xen = xen or dom0
    macros = {'name': name,
              'kversion'  : 'template',
              'initrdCmd' : '',
              'moduleCmd' : '',
              'timeOut'   : '5',
              'bootDev'   : 'hda',
              'kernelCmd' : 'kernel /boot/vmlinuz-%%(kversion)s ro root=LABEL=root %s' % clock}
    if hasInitrd:
        if dom0:
            macros['initrdCmd'] = 'module /boot/initrd-%(kversion)s.img'
        else:
            macros['initrdCmd'] = 'initrd /boot/initrd-%(kversion)s.img'
    macros['moduleCmd'] = ''
    if xen and not dom0:
        macros['bootDev'] = 'xvda'
        macros['timeOut'] = '0'
        macros['kernelCmd'] += ' quiet'
    elif xen and dom0:
        macros['moduleCmd'] = 'module /boot/vmlinuz-%(kversion)s ro ' \
            'root=LABEL=root'
        macros['kernelCmd'] = 'kernel /boot/xen.gz-%(kversion)s'
    header = ('# GRUB configuration generated by rBuilder',
              '#',
              '# Note that you do not have to rerun grub after ' \
                'making changes to this file',
              '#boot=%(bootDev)s',
              'default=0',
              'timeout=%(timeOut)s',
              'hiddenmenu',
             )
    template = ('title %(name)s (%(kversion)s)',
                '    root (hd0,0)',
                '    %(kernelCmd)s',
                '    %(initrdCmd)s',
                '    %(moduleCmd)s',
               )

    config = list(header)
    if includeTemplate:
        config.extend(template)
    config.append('')
    config = '\n'.join(config)

    while '%' in config:
        config = config % macros
    config = '\n'.join([x for x in config.split('\n') if x.strip()])
    config += '\n\n'
    return config

def copyfile(source, target):
    if not os.path.exists(target):
        return util.copyfile(source, target)

def copytree(source, dest, exceptions=None):
    if not exceptions:
        exceptions = []
    for root, dirs, files in os.walk(source):
        root = root.replace(source, '')
        for f in files:
            if not [x for x in exceptions if \
                        re.match(x, util.joinPaths(root, f))]:
                copyfile(util.joinPaths(source, root, f),
                         util.joinPaths(dest, root, f))
        for _dir in dirs:
            this_dir = util.joinPaths(dest, root, _dir)
            if not os.path.exists(this_dir) and not \
                    [x for x in exceptions if \
                         re.match(x, util.joinPaths(root, _dir))]:
                os.mkdir(this_dir)
                dStat = os.stat(util.joinPaths(source, root, _dir))
                os.chmod(this_dir, dStat[stat.ST_MODE])

class GrubInstaller(bootloader.BootloaderInstaller):
    def _get_grub_conf(self):
        if is_SUSE(self.image_root) or is_UBUNTU(self.image_root):
            return 'menu.lst'
        return 'grub.conf'

    def __init__(self, parent, image_root, sectors, heads,
            grub_path='/sbin/grub'):
        bootloader.BootloaderInstaller.__init__(self, parent, image_root,
                sectors, heads)
        self.grub_path = grub_path

    def setup(self):
        if not os.path.exists(util.joinPaths(self.image_root, self.grub_path)):
            log.info("grub not found. skipping setup.")
            return

        util.mkdirChain(util.joinPaths(self.image_root, 'boot', 'grub'))
        # path to grub stage1/stage2 files in rPL/rLS
        util.copytree(
            util.joinPaths(self.image_root, 'usr', 'share', 'grub', '*', '*'),
            util.joinPaths(self.image_root, 'boot', 'grub'))
        # path to grub files in SLES
        if is_SUSE(self.image_root):
            util.copytree(
                util.joinPaths(self.image_root, 'usr', 'lib', 'grub', '*'),
                util.joinPaths(self.image_root, 'boot', 'grub'))
        if is_UBUNTU(self.image_root):
            # path to grub files in x86 Ubuntu
            util.copytree(
                util.joinPaths(self.image_root, 'usr', 'lib', 'grub', 'i386-pc', '*'),
                util.joinPaths(self.image_root, 'boot', 'grub'))
            # path to grub files in x86_64 Ubuntu
            util.copytree(
                util.joinPaths(self.image_root, 'usr', 'lib', 'grub', 'x86_64-pc', '*'),
                util.joinPaths(self.image_root, 'boot', 'grub'))
        util.mkdirChain(util.joinPaths(self.image_root, 'etc'))

        # Create a stub grub.conf
        if os.path.exists(util.joinPaths(self.image_root, 'etc', 'issue')):
            f = open(util.joinPaths(self.image_root, 'etc', 'issue'))
            name = f.readline().strip()
            if not name:
                name = self.jobData['project']['name']
            f.close()
        else:
            name = self.jobData['project']['name']
        bootDirFiles = os.listdir(util.joinPaths(self.image_root, 'boot'))
        xen = bool([x for x in bootDirFiles
            if re.match('vmlinuz-.*xen.*', x)])
        dom0 = bool([x for x in bootDirFiles
            if re.match('xen.gz-.*', x)])
        hasInitrd = bool([x for x in bootDirFiles
            if re.match('initrd-.*.img', x)])

        clock = ""
        if self.jobData['buildType'] == buildtypes.VMWARE_IMAGE:
            if self.arch == 'x86':
                clock = "clock=pit"
            elif self.arch == 'x86_64':
                clock = "notsc"

        conf = getGrubConf(name, hasInitrd, xen, dom0, clock,
                           includeTemplate=not is_SUSE(self.image_root,
                                                       version=11))

        cfgfile = self._get_grub_conf()
        if cfgfile == 'menu.lst':
            if is_SUSE(self.image_root):
                # write /etc/sysconfig/bootloader for SUSE systems
                util.mkdirChain(util.joinPaths(self.image_root, 'etc', 'sysconfig'))
                f = open(
                    util.joinPaths(self.image_root, 'etc', 'sysconfig', 'bootloader'), 'w')
                f.write('CYCLE_DETECTION="no"\n')
                f.write('CYCLE_NEXT_ENTRY="1"\n')
                f.write('LOADER_LOCATION=""\n')
                f.write('LOADER_TYPE="grub"\n')
                if is_SUSE(self.image_root, version=11):
                    f.write('DEFAULT_APPEND="root=LABEL=root showopts"\n')
                    f.write('FAILSAFE_APPEND="root=LABEL=root"\n')
                f.close()

        f = open(util.joinPaths(self.image_root, 'boot', 'grub', cfgfile), 'w')
        f.write(conf)
        f.close()

        os.chmod(util.joinPaths(self.image_root, 'boot', 'grub', cfgfile), 0600)
        # Create the appropriate links
        if cfgfile != 'menu.lst':
            os.symlink('grub.conf', util.joinPaths(
                self.image_root, 'boot', 'grub', 'menu.lst'))
            os.symlink('../boot/grub/grub.conf',
                       util.joinPaths(self.image_root, 'etc', 'grub.conf'))
        if is_SUSE(self.image_root):
            # create /etc/grub.conf as SUSE scripts expect
            f = open(util.joinPaths(self.image_root, 'etc', 'grub.conf'), 'w')
            f.write('setup (hd0)\n')
            f.write('quit\n')
            f.close()

    def install(self):
        # Now that grubby has had a chance to add the new kernel,
        # remove the template entry added in setup()
        if os.path.exists(util.joinPaths(self.image_root, 'sbin', 'grubby')):
            logCall('chroot %s /sbin/grubby '
                    '--remove-kernel=/boot/vmlinuz-template' % self.image_root,
                    ignoreErrors=True)

        # If bootman is present, configure it for grub and run it
        if os.path.exists(util.joinPaths(self.image_root, 'sbin', 'bootman')):
            bootman_config = open(util.joinPaths(self.image_root, 'etc',
                'bootman.conf'), 'w')
            print >> bootman_config, 'BOOTLOADER=grub'
            bootman_config.close()

            bootloader.writeBootmanConfigs(self)
            logCall('chroot "%s" /sbin/bootman' % self.image_root)

        # Workaround for RPL-2423
        cfgfile = self._get_grub_conf()
        grub_conf = util.joinPaths(self.image_root, 'boot', 'grub', cfgfile)
        if os.path.exists(grub_conf):
            contents = open(grub_conf).read()
            contents = re.compile('^default .*', re.M
                ).sub('default 0', contents)
            open(grub_conf, 'w').write(contents)

        if cfgfile == 'menu.lst' and os.path.exists(grub_conf):
            # workaround for bootloader management tools in SUSE writing
            # menu.lst wrong
            f = open(grub_conf)
            newLines = []
            rootdev_re = re.compile('root=/dev/.*? ')
            grubroot_re = re.compile('root \(.*\)')
            doubleboot_re = re.compile('/boot/boot')
            for line in f:
                line = rootdev_re.sub('root=LABEL=root ', line)
                line = grubroot_re.sub('root (hd0,0)', line)
                line = doubleboot_re.sub('/boot', line)
                newLines.append(line)
            contents = ''.join(newLines)
            f = open(grub_conf, 'w')
            f.write(contents)
            f.close()

    def install_mbr(self, root_dir, mbr_device, size):
        # Install grub into the MBR
        #  Assumed:
        # * raw hdd image at mbr_device is bind mounted at root_dir/disk.img
        # * The size requested is an integer multiple of the cylinder size
        bytesPerCylinder = self.sectors * self.heads * constants.sectorSize
        assert not (size % bytesPerCylinder), "The size passed in here must be cylinder aligned"
        cylinders = size / bytesPerCylinder
        grubCmds = "device (hd0) /disk.img\n" \
                   "geometry (hd0) %d %d %d\n" \
                   "root (hd0,0)\n" \
                   "setup (hd0)" % (cylinders,
                        self.heads, self.sectors)

        logCall('echo -e "%s" | '
                'chroot %s sh -c "%s --no-floppy --batch"'
                % (grubCmds, root_dir, self.grub_path))
